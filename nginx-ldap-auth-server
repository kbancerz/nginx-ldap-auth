#!/usr/bin/env python
import base64
import hashlib
import hmac
import time
from collections import namedtuple
from contextlib import contextmanager
from datetime import date
from datetime import datetime
from datetime import timedelta
from urllib.parse import urlparse

from bottle import abort, redirect, request, response, route, run, \
    static_file, template
import click
import ldap

from config import Config, DEFAULT_CONFIG_FILE


Cookie = namedtuple('Cookie', ['data', 'timestamp'])
GroupsCacheEntry = namedtuple('GroupsCacheEntry', ['entry', 'timestamp'])


cfg = None
groups_cache = {}


@contextmanager
def ldap_connection():
    global cfg

    # TODO(kbancerz): add SSL support
    ldap_client = ldap.initialize(f'ldap://{cfg.host}:{cfg.port}')
    try:
        ldap_client.simple_bind_s(cfg.username, cfg.password)
        yield ldap_client
    except ldap.INVALID_CREDENTIALS:
        click.echo('Wrong admin username/password')
        raise
    except ldap.SERVER_DOWN:
        click.echo('Could not connect to LDAP')
        raise
    finally:
        ldap_client.unbind()


def ldap_check_authentication(username, password):
    global cfg

    with ldap_connection() as lc:
        ldap_filter = f'({cfg.user_attr}={username})'
        search_result = lc.search_s(
            cfg.user_base_dn, ldap.SCOPE_SUBTREE, ldap_filter)

    if not search_result:
        click.echo(f'Incorrect credentials: {username}')
        return False

    # TODO(kbancerz): change to bind attempt?
    # get base64-encoded hash of the password from directory
    ldap_password_encoded = search_result[0][1].get('userPassword')
    if ldap_password_encoded is None:
        return False

    ldap_password = base64.b64decode(ldap_password_encoded[0][5:])
    received_password = hashlib.sha1(password.encode('utf-8')).digest()
    if not hmac.compare_digest(ldap_password, received_password):
        click.echo(f'Incorrect credentials: {username}')
        return False

    return True


def ldap_get_group_membership(username):
    global cfg

    # function caches results to make LDAP calls less frequent
    now = int(time.time())
    cache_entry = groups_cache.get(username, None)

    if ((cache_entry is None) or
            (cache_entry.timestamp + cfg.group_cache_max_age < now)):
        with ldap_connection() as lc:
            # get user's DN
            lc_filter = f'({cfg.user_attr}={username})'
            result = lc.search_s(
                cfg.user_base_dn, ldap.SCOPE_SUBTREE, lc_filter)
            user_dn = result[0][0]

            # TODO(kbancerz): parametrize this query
            # find user's groups based on DN
            lc_filter = f'(|(&(objectClass=*)(uniqueMember={user_dn})))'
            result = lc.search_s(
                cfg.group_base_dn, ldap.SCOPE_SUBTREE, lc_filter, ['cn', ])
            groups = {group[0] for group in result}

        cache_entry = GroupsCacheEntry(groups, now)
        groups_cache[username] = cache_entry

    return cache_entry.entry


@route('/static/<filename:path>', method='GET')
def server_static(filename):
    global cfg
    return static_file(filename, root=cfg.static_root)


@route('/auth', method='GET')
def auth():
    global cfg

    ingress = request.get_header('X-LDAP-AUTH-INGRESS')
    if ingress in cfg.ignored_ingress:
        return ''

    cookie = request.get_cookie(cfg.cookie_session, secret=cfg.cookie_secret)
    if not cookie:
        return abort(401, 'Unauthenticated')

    username, timestamp = cookie.rsplit(':', 1)

    # if cfg.cookie_max_age > 0, then interpret it as absolute number of
    # seconds to cookie expiration, otherwise interpret as a number of full
    # days, before expiring at midnight, e.g.:
    #  -> 0 means today at 23:59:59
    #  -> -1 means tomorrow at 23:59:59
    if cfg.cookie_max_age > 0:
        expiration = int(timestamp) + cfg.cookie_max_age
    else:
        midnight = datetime.combine(
            date.fromtimestamp(int(timestamp)), datetime.max.time())
        expiration = \
            (midnight + timedelta(days=-cfg.cookie_max_age)).timestamp()

    if int(expiration) < int(time.time()):
        return abort(401, 'Unauthenticated')

    hdr_allowed_users = request.get_header('X-LDAP-AUTH-USERS')
    hdr_allowed_groups = request.get_header('X-LDAP-AUTH-GROUPS')

    # if user is not on the list of allowed users, then check groups
    # if user is not assigned to any of the allowed groups, then return 403

    if hdr_allowed_users:
        allowed_users = {x.strip() for x in hdr_allowed_users.split(';')}
        if username in allowed_users:
            return ''

    if hdr_allowed_groups:
        allowed_groups = {x.strip() for x in hdr_allowed_groups.split(';')}
        user_groups = ldap_get_group_membership(username)
        if allowed_groups.intersection(user_groups):
            return ''
    else:
        return ''

    return abort(403, 'Unauthorized')


@route('/', method=('GET', 'POST'))
def login():
    global cfg

    if request.method == 'GET':
        return template(cfg.login_template)

    username = request.forms.get('username')
    password = request.forms.get('password')
    if not ldap_check_authentication(username, password):
        return template(
            cfg.login_template,
            error_msg='Incorrect username or password!',
            username=username)

    now = int(time.time())
    cookie_data = f'{username}:{now}'

    # set expiration as described in auth function
    if cfg.cookie_max_age > 0:
        max_age = cfg.cookie_max_age
    else:
        exp_date = date.today() + timedelta(days=-cfg.cookie_max_age)
        exp_ts = datetime.combine(exp_date, datetime.max.time()).timestamp()
        max_age = int(exp_ts) - int(now)

    response.set_cookie(
        cfg.cookie_session, cookie_data, secret=cfg.cookie_secret,
        max_age=max_age, domain=cfg.cookie_domain, path='/', httponly=True)

    next_url = request.cookies.get(cfg.cookie_redirect)
    response.delete_cookie(
        cfg.cookie_redirect, domain=cfg.cookie_domain, path='/')

    return redirect(next_url or cfg.fallback_redirect)


@route('/logout', method=('GET', 'POST'))
def logout():
    global cfg

    response.delete_cookie(
        cfg.cookie_session, domain=cfg.cookie_domain, path='/')
    return redirect('/')


@route('/noauth', method='GET')
def no_authorization():
    global cfg

    cookie = request.get_cookie(cfg.cookie_session, secret=cfg.cookie_secret)

    user = cookie.split(':', 2)[0] if cookie else None
    redirection = request.get_cookie(cfg.cookie_redirect)
    if redirection:
        parsed = urlparse(redirection)
        host = parsed.netloc
    else:
        host = None

    return template(
        cfg.noauth_template, host=host, user=user,
        home=cfg.fallback_redirect)


@click.group()
@click.option('--config-file', required=False, type=click.Path(),
              help='configuration file')
@click.pass_context
def nginx_ldap_auth(ctx, config_file=None):
    """
    nginx LDAP Authentication Server
    """
    ctx.ensure_object(dict)
    ctx.obj['config_file'] = config_file


@nginx_ldap_auth.command()
@click.option('--json-indent', default=4, type=int, help='JSON ident')
@click.pass_context
def get_sample_config(ctx, json_indent):
    """
    Create a sample server configuration file
    """
    config_json = Config.get_sample_config(indent=json_indent)

    config_file = ctx.obj['config_file']
    if config_file:
        with open(config_file, 'w') as f:
            f.write(config_json)
    else:
        click.echo(config_json)


@nginx_ldap_auth.command()
@click.option('--host', default='0.0.0.0', type=str, help='HTTP host')
@click.option('--port', default=8088, type=int, help='HTTP port to open')
@click.pass_context
def run_server(ctx, host, port):
    """
    Run nginx LDAP Authentication Server
    """
    global cfg

    config_file = ctx.obj['config_file'] or DEFAULT_CONFIG_FILE
    with open(config_file, 'r') as f:
        cfg = Config(f.read())

    missing_config_nodes = cfg.check_consistency()
    if missing_config_nodes:
        click.echo(f'Missing configuration nodes: {missing_config_nodes}')
        exit(1)

    run(host=host, port=port)


if __name__ == '__main__':
    nginx_ldap_auth(obj={}, auto_envvar_prefix='NGINX_LDAP_AUTH')
